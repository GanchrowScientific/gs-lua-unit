/* Copyright Â© 2018 Ganchrow Scientific, SA all rights reserved */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.TYPEOF_UNDEFINED = 'undefined';
exports.TYPEOF_NUMBER = 'number';
exports.TYPEOF_STRING = 'string';
exports.TYPEOF_OBJECT = 'object';
exports.TYPEOF_FUNCTION = 'function';
exports.NOOP = () => { };
exports.isJSON = Object.defineProperties(function (str) {
    if (typeof str === 'string') {
        return (str === 'false') || (str === 'true') ||
            (exports.isJSON.BEGIN_OBJECT_JSON.test(str) && exports.isJSON.END_OBJECT_JSON.test(str)) ||
            (exports.isJSON.BEGIN_ARRAY_JSON.test(str) && exports.isJSON.END_ARRAY_JSON.test(str));
    }
    else if (str instanceof Buffer) {
        return exports.isJSON.isFalseBuffer(str) || exports.isJSON.isTrueBuffer(str) ||
            (str[0] === exports.isJSON.BUFFER_BEGIN_OBJECT_JSON && str[str.length - 1] === exports.isJSON.BUFFER_END_OBJECT_JSON) ||
            (str[0] === exports.isJSON.BUFFER_BEGIN_ARRAY_JSON && str[str.length - 1] === exports.isJSON.BUFFER_END_ARRAY_JSON);
    }
    throw new TypeError('Argument is neither string nor Buffer');
}, {
    FALSE_BUFFER: { value: Buffer.from('false') },
    TRUE_BUFFER: { value: Buffer.from('true') },
    isFalseBuffer: { value: (buf) => exports.isJSON.FALSE_BUFFER.every((b, i) => b === buf[i]) },
    isTrueBuffer: { value: (buf) => exports.isJSON.TRUE_BUFFER.every((b, i) => b === buf[i]) },
    BEGIN_OBJECT_JSON: { value: /^\{/ },
    END_OBJECT_JSON: { value: /\}$/ },
    BEGIN_ARRAY_JSON: { value: /^\[/ },
    END_ARRAY_JSON: { value: /\]$/ },
    BUFFER_BEGIN_OBJECT_JSON: { value: '{'.codePointAt(0) },
    BUFFER_END_OBJECT_JSON: { value: '}'.codePointAt(0) },
    BUFFER_BEGIN_ARRAY_JSON: { value: '['.codePointAt(0) },
    BUFFER_END_ARRAY_JSON: { value: ']'.codePointAt(0) }
});
exports.isXML = Object.defineProperties(function (str) {
    if (typeof str === 'string') {
        return exports.isXML.XML_REGEXP.test(str);
    }
    else if (str instanceof Buffer) {
        return (str[0] === exports.isXML.BUFFER_BEGIN_XML) && (str[str.length - 1] === exports.isXML.BUFFER_END_XML);
    }
    throw new TypeError('Argument is neither string nor Buffer');
}, {
    XML_REGEXP: { value: /^<[\s\S]*>$/ },
    BUFFER_BEGIN_XML: { value: '<'.codePointAt(0) },
    BUFFER_END_XML: { value: '>'.codePointAt(0) }
});
class BasicObject extends null {
    constructor() {
        return Object.create(null);
    }
}
exports.BasicObject = BasicObject;
class SimpleStore {
    constructor() {
        this.obj = {};
    }
    fetch(keyOrValue) {
        return this.obj[keyOrValue] || keyOrValue;
    }
    store(currentValue, nextValue) {
        let finalValue = currentValue;
        if (nextValue) {
            this.obj[currentValue] = nextValue;
            finalValue = nextValue;
        }
        return finalValue;
    }
    clear() {
        this.obj = {};
    }
}
exports.SimpleStore = SimpleStore;
function toArray(obj) {
    return Array.isArray(obj) ? obj : obj === undefined ? [] : [obj];
}
exports.toArray = toArray;
function isFunction(fn) {
    return typeof fn === exports.TYPEOF_FUNCTION;
}
exports.isFunction = isFunction;
function isNumber(n) {
    return typeof n === exports.TYPEOF_NUMBER;
}
exports.isNumber = isNumber;
function isString(s) {
    return typeof s === exports.TYPEOF_STRING;
}
exports.isString = isString;
function isUndefined(d) {
    return typeof d === exports.TYPEOF_UNDEFINED;
}
exports.isUndefined = isUndefined;
function isObject(obj) {
    return obj != null && typeof obj === exports.TYPEOF_OBJECT;
}
exports.isObject = isObject;
function isStrictObject(obj) {
    return isObject(obj) && !Array.isArray(obj);
}
exports.isStrictObject = isStrictObject;
function ensureObject(obj, field) {
    return isStrictObject(obj[field]) && obj[field] || (obj[field] = {});
}
exports.ensureObject = ensureObject;
function deepEnsureObject(obj, fields) {
    let field;
    let stringifiedFields = fields.map(String);
    while (field = stringifiedFields.shift()) {
        obj = ensureObject(obj, field);
    }
    return obj;
}
exports.deepEnsureObject = deepEnsureObject;
function deepFreeze(obj) {
    if (isObject(obj) || typeof obj === 'function') {
        Object.freeze(obj);
        Object.keys(obj).forEach(key => {
            deepFreeze(obj[key]);
        });
    }
    return obj;
}
exports.deepFreeze = deepFreeze;
/**
 * Deeply sets a value on an object if the list of nested fields exist.
 * The nested objects will be recursivey traversed in the order specified by
 * the parameters. If none of the objects are missing, the final value will
 * be set.
 *
 * @param  {Object}     obj object to set value on
 * @param  {any}        val the value to set
 * @param  {(string |   number)[]}   ...fields  the list of fields to traverse in order to set the value
 * @return {boolean}        true if the field set exists on the object. false otherwise.
 */
function safeSetProperty(obj, val, ...fields) {
    if (fields.length === 0) {
        throw new Error('Must specify at least one field');
    }
    if (typeof obj === 'undefined' || obj === null) {
        throw new Error('Must supply an object');
    }
    while (fields.length > 1) {
        let field = fields.shift();
        obj = obj[field];
        if (typeof obj === 'undefined') {
            return false;
        }
    }
    obj[fields.shift()] = val;
    return true;
}
exports.safeSetProperty = safeSetProperty;
function dup(obj, ignoreKeys = []) {
    let cb = (k, v) => {
        if (ignoreKeys.includes(k)) {
            return undefined;
        }
        else if (v === Infinity) {
            return 'Infinity';
        }
        return v;
    };
    return JSON.parse(JSON.stringify(obj, cb), (k, v) => {
        if (v === 'Infinity') {
            return Infinity;
        }
        else {
            return v;
        }
    });
}
exports.dup = dup;
function valuesAtCreate(...keys) {
    return (obj) => {
        return keys.map(key => obj[key]);
    };
}
exports.valuesAtCreate = valuesAtCreate;
function allArrayItemTypesMatch(array) {
    return array.every(isSameTypeOf(array[0]));
}
exports.allArrayItemTypesMatch = allArrayItemTypesMatch;
function isSameTypeOf(chkVal) {
    return (val) => {
        return typeof chkVal === typeof val;
    };
}
exports.isSameTypeOf = isSameTypeOf;
function isNumeric(value) {
    return (!!value || value === 0) && value !== true && !Array.isArray(value) &&
        !isNaN(value) && String(value).length !== 0;
}
exports.isNumeric = isNumeric;
class CaseInsensitiveBucket {
    constructor(...args) {
        this.obj = new Set();
        args.forEach(arg => {
            this.obj.add(String(arg).toLowerCase());
        });
    }
    has(key) {
        return this.obj.has(String(key).toLowerCase());
    }
}
exports.CaseInsensitiveBucket = CaseInsensitiveBucket;
function stripAnyValues(obj, ...args) {
    let dupItems = dup(obj);
    toArray(dupItems).forEach(item => {
        args.forEach(arg => {
            delete item[arg];
        });
    });
    return dupItems;
}
exports.stripAnyValues = stripAnyValues;
function flattenArray(ary) {
    return ary.reduce((b, c) => b.concat(c), []);
}
exports.flattenArray = flattenArray;
function stringifyJSONNoEmptyArrays(obj) {
    return JSON.stringify(obj, function (key, value) {
        if (!Array.isArray(value) || value.length) {
            return value;
        }
    });
}
exports.stringifyJSONNoEmptyArrays = stringifyJSONNoEmptyArrays;
function multiArraySome(arrays, match, index) {
    return arrays.some(array => {
        if (isFunction(match)) {
            return array.some(match);
        }
        return isNumber(index) ? toArray(array)[index] === match :
            toArray(array).includes(match);
    });
}
exports.multiArraySome = multiArraySome;
function multiArrayEvery(arrays, match, index) {
    return arrays.every(array => {
        if (isFunction(match)) {
            return array.every(match);
        }
        return isNumber(index) ? toArray(array)[index] === match :
            toArray(array).includes(match);
    });
}
exports.multiArrayEvery = multiArrayEvery;
function hasAllPropertyValues(main, other) {
    return Object.keys(main).every(key => {
        if (isObject(main[key])) {
            if (isObject(other[key])) {
                return hasAllPropertyValues(main[key], other[key]);
            }
        }
        else {
            return main[key] === other[key];
        }
    });
}
exports.hasAllPropertyValues = hasAllPropertyValues;
/**
 * Checks that both arrays are the same size and every element in the first array exists in the second.
 * If one array is falsy, then the other array must be empty or falsy for this function to return true.
 * @param  {any[]}   first
 * @param  {any[]}   second
 * @return {boolean}        true if every element of the first array exists in the second they are the same size
 */
function arraysEquivalent(first, second) {
    first = first || [];
    second = second || [];
    return first.length === second.length && first.every(val => second.includes(val));
}
exports.arraysEquivalent = arraysEquivalent;
/**
 * Checks that every element of a is present in b, but a can be a subset of b
 * @param  {any[]}   a
 * @param  {any[]}   b
 * @return {boolean} true if every element of the first array exists in the second
 */
function arrayIsSubset(a, b) {
    a = a || [];
    b = b || [];
    return a.every(el => b.includes(el));
}
exports.arrayIsSubset = arrayIsSubset;
function arrayPartition(array, partition) {
    return array.reduce((part, item) => (part[partition(item) ? 0 : 1].push(item), part), [[], []]);
}
exports.arrayPartition = arrayPartition;
function swapItems(item) {
    if (Array.isArray(item)) {
        let it = item[0];
        item[0] = item[1];
        item[1] = it;
    }
    return item;
}
exports.swapItems = swapItems;
function leftDigit(x, n = 1) {
    if ((n < 1) || (10 ** (n - 1) > x)) {
        return 0;
    }
    return Math.floor(x / 10 ** (Math.floor(Math.log10(x) - n + 1)));
}
exports.leftDigit = leftDigit;
function convertArrayValuesToObject(obj) {
    return Object.keys(obj).reduce((arr, key) => {
        toArray(obj[key]).forEach((val, vidx) => {
            Object.assign(arr[vidx] = arr[vidx] || {}, { [key]: val });
        });
        return arr;
    }, []);
}
exports.convertArrayValuesToObject = convertArrayValuesToObject;
function rejectKeys(obj, ...keys) {
    return keys.reduce((o, k) => {
        let val = obj[k];
        delete obj[k];
        return (o[k] = val, o);
    }, {});
}
exports.rejectKeys = rejectKeys;
function pickKeys(obj, ...keys) {
    return keys.reduce((o, k) => {
        let val = obj[k];
        return (o[k] = isObject(val) ? dup(val) : val, o);
    }, {});
}
exports.pickKeys = pickKeys;
function shuffleArray(array) {
    return array.sort(_ => Math.random() < Math.random() ? -1 : 1);
}
exports.shuffleArray = shuffleArray;
function leftPad(n) {
    return n < 10 ? `0${n}` : `${n}`;
}
exports.leftPad = leftPad;
function isToday(utcMilliSeconds) {
    let todayMidnight = new Date();
    todayMidnight.setHours(0, 0, 0, 0);
    let tomorrowMidnight = new Date();
    tomorrowMidnight.setHours(0, 0, 0, 0);
    tomorrowMidnight.setDate(tomorrowMidnight.getDate() + 1);
    return todayMidnight.getTime() <= utcMilliSeconds && utcMilliSeconds < tomorrowMidnight.getTime();
}
exports.isToday = isToday;
//# sourceMappingURL=utilities.js.map