export declare const TYPEOF_UNDEFINED = "undefined";
export declare const TYPEOF_NUMBER = "number";
export declare const TYPEOF_STRING = "string";
export declare const TYPEOF_OBJECT = "object";
export declare const TYPEOF_FUNCTION = "function";
export declare const NOOP: () => void;
export declare type Bing = string | Buffer;
export declare type ParsedJson = any;
export declare const isJSON: any;
export declare const isXML: any;
export declare type OptArgCbFunc = (err?: Error, res?: any) => void;
export declare type NoArgVoidFunc = () => void;
export declare type ErrorArgVoidFunc = (err: Error) => void;
export declare type AnyVoidFunc = (...args: any[]) => void;
export declare class BasicObject extends null {
    constructor();
}
export declare class SimpleStore {
    private obj;
    fetch(keyOrValue: any): any;
    store(currentValue: any, nextValue: any): any;
    clear(): void;
}
export declare function toArray<T>(obj?: T[] | T): T[];
export declare function isFunction(fn: any): boolean;
export declare function isNumber(n: any): boolean;
export declare function isString(s: any): boolean;
export declare function isUndefined(d: any): boolean;
export declare function isObject(obj: any): boolean;
export declare function isStrictObject(obj: any): boolean;
export declare function ensureObject(obj: Object, field: string): Object;
export declare function deepEnsureObject(obj: Object, fields: (string | number)[]): Object;
export declare function deepFreeze<T>(obj: T): T;
/**
 * Deeply sets a value on an object if the list of nested fields exist.
 * The nested objects will be recursivey traversed in the order specified by
 * the parameters. If none of the objects are missing, the final value will
 * be set.
 *
 * @param  {Object}     obj object to set value on
 * @param  {any}        val the value to set
 * @param  {(string |   number)[]}   ...fields  the list of fields to traverse in order to set the value
 * @return {boolean}        true if the field set exists on the object. false otherwise.
 */
export declare function safeSetProperty(obj: Object, val: any, ...fields: (string | number)[]): boolean;
export declare function dup<T>(obj: T, ignoreKeys?: string[]): ParsedJson;
export declare function valuesAtCreate(...keys: any[]): (obj: Object) => Array<any>;
export declare function allArrayItemTypesMatch(array: Array<any>): boolean;
export declare function isSameTypeOf(chkVal: any): (val: any) => boolean;
export declare function isNumeric(value: any): boolean;
export declare class CaseInsensitiveBucket {
    private obj;
    constructor(...args: string[]);
    has(key: string): boolean;
}
export declare function stripAnyValues<T>(obj: T, ...args: any[]): ParsedJson;
export declare function flattenArray(ary: any[]): any[];
export declare function stringifyJSONNoEmptyArrays(obj: any): string;
export declare function multiArraySome(arrays: any[][], match: any, index?: number): boolean;
export declare function multiArrayEvery(arrays: any[][], match: any, index?: number): boolean;
export declare function hasAllPropertyValues(main: Object, other: Object): boolean;
/**
 * Checks that both arrays are the same size and every element in the first array exists in the second.
 * If one array is falsy, then the other array must be empty or falsy for this function to return true.
 * @param  {any[]}   first
 * @param  {any[]}   second
 * @return {boolean}        true if every element of the first array exists in the second they are the same size
 */
export declare function arraysEquivalent(first?: any[], second?: any[]): boolean;
/**
 * Checks that every element of a is present in b, but a can be a subset of b
 * @param  {any[]}   a
 * @param  {any[]}   b
 * @return {boolean} true if every element of the first array exists in the second
 */
export declare function arrayIsSubset(a: any[], b: any[]): boolean;
export declare function arrayPartition<T>(array: T[], partition: (item: any) => boolean): [T[], T[]];
export declare function swapItems<T extends Array<any>>(item: T): T;
export declare function leftDigit(x: number, n?: number): number;
export declare function convertArrayValuesToObject(obj: {
    [a: string]: any[];
}): {
    [a: string]: any;
}[];
export declare function rejectKeys<O, K extends keyof O>(obj: O, ...keys: K[]): Pick<O, K>;
export declare function pickKeys<O, K extends keyof O>(obj: O, ...keys: K[]): Pick<O, K>;
export declare function shuffleArray(array: any[]): any[];
export declare function leftPad(n: number): string;
export declare function isToday(utcMilliSeconds: number): boolean;
