/* Copyright Â© 2016-2017 Ganchrow Scientific, SA all rights reserved */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const bufferpack = require("bufferpack");
class ByteSizedChunker {
    constructor(bufferHeaderLength, packFormat) {
        this.bufferHeaderLength = bufferHeaderLength;
        this.packFormat = packFormat;
        this.partial = Buffer.alloc(0);
    }
    prepare(data, dataType = 'ascii') {
        let dataBuf = Buffer.isBuffer(data) ? data : Buffer.from(data, dataType);
        return Buffer.concat([
            bufferpack.pack(this.packFormat, [dataBuf.length]),
            dataBuf
        ]);
    }
    forEachCompleteChunk(dataBuf, cb) {
        this.partial = Buffer.concat([this.partial, dataBuf]);
        while (this.partial.length >= this.bufferHeaderLength +
            this.getExpectedMessageSize(this.partial)) {
            cb(this.getMessage(this.partial));
            this.partial = this.getNextPartial(this.partial);
        }
    }
    getExpectedMessageSize(data) {
        if (data.length < this.bufferHeaderLength) {
            return Number.POSITIVE_INFINITY;
        }
        return bufferpack.unpack(this.packFormat, data.slice(0, this.bufferHeaderLength))[0];
    }
    getMessage(data) {
        return data.slice(this.bufferHeaderLength, this.bufferHeaderLength + this.getExpectedMessageSize(data));
    }
    getNextPartial(data) {
        return data.slice(this.bufferHeaderLength + this.getExpectedMessageSize(data));
    }
}
exports.ByteSizedChunker = ByteSizedChunker;
//# sourceMappingURL=byteSizedChunker.js.map